import argparse
import logging
import pickle
from typing import List, Tuple, Dict, Union
from utils.config_manager import config
from utils.logging_setup import setup_logging
from utils.file_operations import create_directories, get_all_file_paths
from utils.data_preprocessing import process_files_in_batches
from utils.hmm_training import load_model, score_file
from utils.sequence_operations import save_sequences

def parse_arguments() -> argparse.Namespace:
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description="Malware detection using HMM")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging")
    parser.add_argument("--limit", type=int, default=None, help="Limit the number of files to load")
    parser.add_argument("--directories", nargs='+', default=['input'], help="Directories to load files from")
    parser.add_argument("--use-saved", action="store_true", help="Use saved opcode and numeric sequences for classification")
    return parser.parse_args()

def save_classification_sequences(opcode_sequences: List[List[str]], numeric_sequences: List[List[int]], opcode_map: Dict[Union[bytes, int], int], file_paths: List[str], file_sequence_lengths: Dict[str, List[int]]):
    """Save processed classification sequences to file for faster future loading."""
    data = {
        'opcode_sequences': opcode_sequences,
        'numeric_sequences': numeric_sequences,
        'opcode_map': opcode_map,
        'file_paths': file_paths,
        'file_sequence_lengths': file_sequence_lengths
    }
    save_path = config.get('classification.sequences_file', 'models/classification_sequences.pkl')
    with open(save_path, 'wb') as f:
        pickle.dump(data, f)
    logging.info(f"Saved processed classification sequences to {save_path}")

def load_classification_sequences():
    """Load processed classification sequences from file."""
    load_path = config.get('classification.sequences_file', 'models/classification_sequences.pkl')
    with open(load_path, 'rb') as f:
        data = pickle.load(f)
    logging.info(f"Loaded processed classification sequences from {load_path}")
    return data['opcode_sequences'], data['numeric_sequences'], data['opcode_map'], data['file_paths'], data['file_sequence_lengths']

def main() -> None:
    """Main function to run the malware classification process."""
    args = parse_arguments()
    create_directories()
    setup_logging(debug=args.debug)

    logging.info("Starting malware classification process")

    if args.use_saved:
        try:
            all_opcode_sequences, all_numeric_sequences, opcode_map, file_paths, file_sequence_lengths = load_classification_sequences()
            print(file_sequence_lengths)
            logging.info("Using saved sequences for classification")
        except FileNotFoundError:
            logging.error("Saved sequences not found. Please run without --use-saved to generate sequences.")
            return
    else:
        # Load test files
        file_paths = get_all_file_paths(args.directories, limit=args.limit)
        logging.info(f"Found {len(file_paths)} files for classification")

        if not file_paths:
            logging.warning("No files found for classification. Please check the input directories.")
            return

        batch_size = config.get('classification.batch_size', 1000)

        try:
            # Load the trained HMM model
            hmm_model = load_model(config.get('model.trained_hmm_file', 'models/trained_hmm.pkl'))

            # Process test files
            all_opcode_sequences, all_numeric_sequences, opcode_map, file_sequence_lengths = process_files_in_batches(file_paths, batch_size, remove_duplicates=False, debug=args.debug)
            
            # Save processed classification sequences with different names
            save_classification_sequences(all_opcode_sequences, all_numeric_sequences, {}, file_paths, file_sequence_lengths)

        except Exception as e:
            logging.error(f"Error during classification: {e}")
            return

    # Load the trained HMM model
    hmm_model = load_model(config.get('model.trained_hmm_file', 'models/trained_hmm.pkl'))

    # If sequences are loaded from file, proceed to classification
    scores = {}
    classifications = {}
    
    # Get threshold from config or use a default value
    threshold = config.get('classification.threshold', -2.30)

    # Process sequences based on file_sequence_lengths
    start_index = 0
    for file_path, lengths in file_sequence_lengths.items():
        end_index = start_index + len(lengths)
        file_sequences = all_numeric_sequences[start_index:end_index]
        
        logging.debug(f"Scoring numeric sequences for {file_path}")
        score, is_malicious = score_file(hmm_model, file_sequences, threshold)
        scores[file_path] = score
        classifications[file_path] = is_malicious
        logging.info(f"Score for {file_path}: {score}, Malicious: {is_malicious}")
        
        start_index = end_index

    # Write scores and classifications to the output file
    output_file = config.get('classification.output_file', 'output/classification_results.txt')
    with open(output_file, 'w') as f:
        f.write(f"Threshold: {threshold}\n\n")
        for file_path, score in scores.items():
            f.write(f"File: {file_path}\n")
            f.write(f"Score: {score}\n")
            f.write(f"Malicious: {classifications[file_path]}\n\n")
    
    logging.info(f"Classification results saved to {output_file}")

    # Calculate and log overall statistics
    total_files = len(scores)
    if total_files > 0:
        malicious_files = sum(classifications.values())
        benign_files = total_files - malicious_files

        logging.info(f"Total files classified: {total_files}")
        logging.info(f"Malicious files detected: {malicious_files}")
        logging.info(f"Benign files detected: {benign_files}")
        logging.info(f"Malicious file percentage: {(malicious_files / total_files) * 100:.2f}%")
    else:
        logging.warning("No files were classified. Please check your input data and configuration.")

if __name__ == "__main__":
    main()