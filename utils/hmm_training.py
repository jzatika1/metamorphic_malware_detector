import pickle
import numpy as np
from collections import Counter
from typing import List, Tuple, Union, Dict
from hmmlearn import hmm
from utils.config_manager import config
from utils.logger import Logger

def train_hmm(opcode_sequences: List[List[int]], n_states: int, n_iter: int, random_seed: int, thresh: float, verbose: bool, logger=None):
    """
    Train an HMM model on the given opcode sequences.
    """
    if logger is None:
        logger = Logger.setup('hmm_training')

    logger.info(f"Starting HMM training with {n_states} states, {n_iter} iterations")
    Logger.debug(logger, f"Random seed: {random_seed}, Threshold: {thresh}, Verbose: {verbose}")

    np.set_printoptions(threshold=np.inf, suppress=True)
    
    opcodes_combined = np.concatenate([np.array(seq) for seq in opcode_sequences])
    unique_opcodes = np.unique(opcodes_combined)
    
    opcode_to_index = {op: i for i, op in enumerate(unique_opcodes)}
    lengths = [len(seq) for seq in opcode_sequences]
    
    X = np.array([opcode_to_index[op] for seq in opcode_sequences for op in seq]).reshape(-1, 1)
    
    logger.info(f"Prepared {len(opcode_sequences)} sequences for training")
    Logger.debug(logger, f"Total opcodes: {len(opcodes_combined)}, Unique opcodes: {len(unique_opcodes)}")

    model = hmm.CategoricalHMM(n_components=n_states, n_iter=n_iter, random_state=random_seed, verbose=verbose, tol=thresh)
    
    logger.info("Fitting HMM model")
    model.fit(X, lengths)
    logger.info("HMM model training completed")

    return model

def save_model(model, file_path: str, logger=None) -> None:
    """
    Save the trained HMM model to a file.

    Args:
        model: Trained HMM model.
        file_path (str): Path to save the model.
        logger (logging.Logger, optional): Logger instance.
    """
    if logger is None:
        logger = Logger.setup('hmm_training')

    logger.info(f"Saving HMM model to {file_path}")
    with open(file_path, 'wb') as file:
        pickle.dump(model, file)
    logger.info("HMM model saved successfully")

def load_model(file_path: str, logger=None):
    """
    Load the trained HMM model from a file.

    Args:
        file_path (str): Path to the saved model file.
        logger (logging.Logger, optional): Logger instance.

    Returns:
        hmm.MultinomialHMM: Loaded HMM model.
    """
    if logger is None:
        logger = Logger.setup('hmm_training')

    logger.info(f"Loading HMM model from {file_path}")
    with open(file_path, 'rb') as file:
        model = pickle.load(file)
    logger.info("HMM model loaded successfully")
    return model

def train_and_save_hmm_model(numeric_sequences: List[List[int]], logger=None) -> None:
    """
    Train an HMM model on the given numeric sequences and save it.

    Args:
        numeric_sequences (List[List[int]]): List of numeric sequences to train on.
        logger (logging.Logger, optional): Logger instance.
    """
    if logger is None:
        logger = Logger.setup('hmm_training')

    logger.info("Starting HMM model training and saving process")

    n_states = config.get('model.hmm.n_states', 4)
    n_iter = config.get('model.hmm.n_iter', 1000)
    tol = config.get('model.hmm.tol', 0.01)
    random_seed = config.get('model.hmm.random_seed', 0)
    verbose = config.get('model.hmm.verbose', True)
    
    Logger.debug(logger, f"HMM parameters: n_states={n_states}, n_iter={n_iter}, tol={tol}, random_seed={random_seed}, verbose={verbose}")

    hmm_model = train_hmm(numeric_sequences, n_states, n_iter=n_iter, random_seed=random_seed, thresh=tol, verbose=verbose, logger=logger)

    save_path = config.get('model.trained_hmm_file', 'models/trained_hmm.pkl')
    save_model(hmm_model, save_path, logger=logger)

    logger.info("HMM model training and saving completed")

def score_file(hmm_model, opcode_sequences: Union[List[List[int]], List[int]], threshold: float = -5.0, logger=None) -> Tuple[float, bool]:
    """
    Score a file using the HMM model and determine if it's malicious.
    Args:
        hmm_model: Trained HMM model.
        opcode_sequences (Union[List[List[int]], List[int]]): List of numeric opcode sequences or a single sequence.
        threshold (float): Threshold for determining maliciousness.
        logger (logging.Logger, optional): Logger instance.
    Returns:
        Tuple[float, bool]: Average normalized log probability score and maliciousness flag.
    """
    if logger is None:
        logger = Logger.setup('hmm_training')

    logger.info("Scoring file using HMM model")
    Logger.debug(logger, f"Threshold: {threshold}")

    total_normalized_logprob = 0
    sequence_count = 0
    
    if isinstance(opcode_sequences[0], int):
        opcode_sequences = [opcode_sequences]
    
    Logger.debug(logger, f"Total sequences to score: {len(opcode_sequences)}")

    for sequence in opcode_sequences:
        try:
            sequence_array = np.array(sequence).reshape(-1, 1)
            logprob = hmm_model.score(sequence_array)
            sequence_length = len(sequence)
            
            if np.isinf(logprob):
                Logger.debug(logger, f"Infinite log probability for sequence of length {sequence_length}")
                continue
            
            normalized_logprob = logprob / sequence_length if sequence_length > 0 else logprob
            total_normalized_logprob += normalized_logprob
            sequence_count += 1
        except Exception as e:
            Logger.debug(logger, f"Error scoring sequence: {str(e)}")
            continue
    
    if sequence_count > 0:
        average_normalized_logprob = total_normalized_logprob / sequence_count
        is_malicious = average_normalized_logprob > threshold
        logger.info(f"File scored. Average normalized log probability: {average_normalized_logprob}")
        logger.info(f"Classification: {'Malicious' if is_malicious else 'Benign'}")
    else:
        average_normalized_logprob = float('-inf')
        is_malicious = False
        logger.warning("No valid sequences to score")
    
    return average_normalized_logprob, is_malicious

def score_file_sequences(hmm_model, numeric_sequences: List[List[int]], file_sequence_lengths: Dict[str, List[int]], threshold: float, logger=None) -> Dict[str, Tuple[float, bool]]:
    """
    Score sequences for each file based on file sequence lengths.
    
    Args:
        hmm_model: The trained HMM model.
        numeric_sequences (List[List[int]]): All numeric sequences.
        file_sequence_lengths (Dict[str, List[int]]): Dictionary of file paths to their sequence lengths.
        threshold (float): Classification threshold.
        logger (logging.Logger, optional): Logger instance.
    
    Returns:
        Dict[str, Tuple[float, bool]]: Dictionary of file paths to their scores and classifications.
    """
    if logger is None:
        logger = Logger.setup('hmm_training')

    logger.info("Starting to score file sequences")
    Logger.debug(logger, f"Total files to score: {len(file_sequence_lengths)}")

    results = {}
    start_index = 0
    for file_path, lengths in file_sequence_lengths.items():
        logger.info(f"Scoring file: {file_path}")
        end_index = start_index + len(lengths)
        file_sequences = numeric_sequences[start_index:end_index]
        score, is_malicious = score_file(hmm_model, file_sequences, threshold, logger=logger)
        results[file_path] = (score, is_malicious)
        start_index = end_index

    logger.info("File sequence scoring completed")
    return results